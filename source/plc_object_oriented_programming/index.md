# PLCオブジェクト指向プログラミング

IEC61131-3の第3版では、オブジェクト指向を用いたプログラミングが可能です。IECではクラスという概念が定義されていますが、TwinCATでは同じカプセル化を実現する方法として旧来からあるファンクションブロックを拡張する形でクラスの機能を追加しました。

ファンクションブロックにある旧来からのカプセル化の機構としては、`VAR_INPUT, VAR_OUTPUT`とするアクセッサを通してのみデータにアクセスできる、といったものがあります。これらを次の方法で参照やポインタといった機能を組み合わせることで、様々な抽象化を実現していました。

ポインタの活用
    : `ADR`関数を用いる事で、該当する変数のポインタを返します。型名には、`POINTER TO ****`とアクセッサに宣言する事で、ファンクションブロック外部のデータを参照渡しする事ができます。また、単にメモリ上のアドレスを受け渡すだけですので、サイズが明確であれば、実装側のプログラムが指定する型を意識することなくファンクションブロック内部で処理する事ができます。

リファレンスの活用
    : 前述の通り型を意識することなくデータを操作する事ができるポインタは扱い方により危険です。コンパイラにより型による制約を保証する参照機構として「リファレンス」というものがあります。
    ファンクションブロック内で`REFERENCE TO ****`として宣言したものは、外部からリファレンスを渡す事で参照渡しする事ができます。ファンクションブロックの内外共に明確な型として扱う事ができるなら、リファレンスを用いる方が安全です。

VAR_IN_OUTの活用
    : `VAR_IN_OUT`で受け渡す変数は、暗黙的に参照渡しとなっています。他社のIECのプログラムスキームでは、入力端だけでなく出力端にも外部変数を紐づける事を強制するものがありますが、TwinCATの場合は、入力端だけに外部変数を紐づけます。これにより紐づけた外部変数へファンクションブロック内部でデータを書き込む事ができます。

また、これらのデータを受け取って処理するロジックは、ファンクションブロック本体に一つだけ記述可能なものです。よって外部から処理させたい内容を切り替えるには、外部から状態変数により`IF`文や`CASE`文等で条件分岐しながら実行する、といった必要がありました。

これに対して、IEC61131-3の第3版で新たに定義されたオブジェクト指向としてのファンクションブロックへ次の機構が追加されました。

プロパティ
    : `GET`はファンクションブロック内部の変数を外部へ読み出すためのアクセス機構です。また、`SET`は外部の変数の値をファンクションブロック内部の変数へ書き込むためのアクセス機構です。

メソッド
    : 従来ファンクションブロックのボディに一つだけ定義できたものを、任意の名前を付けて複数の処理を定義する機構をメソッドと呼びます。外部のプログラム、および、ファンクションブロック内部のプログラムロジックが明示的に任意のメソッドを呼び出して処理を行う事ができます。

インターフェースと継承
    : 他のファンクションブロックの機能を継承して追加実装する機構や、共通のインターフェースを備えた抽象クラスを読み込んで実行するファンクションブロックを定義する事で、インターフェース実装した派生のファンクションブロックをダイナミックに実行させることができます。

```{csv-table}
:header: ファンクションブロックの機能, 従来, オブジェクト指向

アクセッサ, `VAR_INPUT`、`VAR_OUTPUT`、`VAR_IN_OUT` , プロパティの`GET`と`SET`
処理ロジック, ボディに一つだけ定義可能, メソッドとして複数定義可能
多態性の実現方法, ポインタ、参照, ポインタ、参照、インターフェース
継承機能の違い, 全てのアクセッサへアクセス可能, 親クラスを`SUPER^`、自クラスを`THIS^`としたポインタを通してメソッドやアクセッサへアクセスする必要がある。
```




```{toctree}
:hidden:

object_interface
sample_universal_activity
solid
```