# インターフェースの活用

インターフェースとは、ファンクションブロックに実装するべき共通のメソッドやプロパティ、また、その引数の型と戻り値を定義するための仕組みです。定義したインターフェースを実装（implementation）する際に、あらかじめ定義したプロパティとメソッドの実装を強制されます。

![](assets/2024-01-09-13-54-07.png){align=center}

これを実装したファンクションブロックは、さまざまなバリエーションのものを複数作ったとしても、同じメソッドやプロパティを持つことが保証されます。上記の例では、次の二つのファンクションブロックがいずれも`I_Observer`インターフェースを実装しており、どちらも`send_signal`メソッドを持っています。

* FB_AlarmSimpleListerner 
* FB_AlarmDBListener

そしてメインプログラムとして、インターフェース型の変数を通してプロパティとメソッドにアクセスするプログラムを構築します。

図の例では`FB_AlarmCalculator`ファンクションブロックとなります。このファンクションブロックには、インターフェース型で定義したオブジェクトを読み込むメソッド`add_listener`が用意されており、これを通じてインターフェースを実装したファンクションブロックを読み込みます。このあと、読み込まれたオブジェクトの`send_signal`メソッドを実行するプログラムが組まれています。つまり、読み込む派生オブジェクトによって異なるメソッドの処理を実行することができますが、その呼び出し元となるプログラムは同一プログラムです。（解説例：{ref}`alarm_system_library`）

このような機能を、オブジェクト指向における重要な機能である、ポリモーフィズム（Polymorphism）または、多相性、多態性と呼びます。共通部分のロジックと派生部分のモジュールを分けて開発を進めることで、不要な部分へのプログラム変更の影響を及ぼすことなく、柔軟に機能を拡張させることが可能になります。

```{note}
プログラムの高い保守性、生産性を維持するための原則を述べたものとして、頭文字をとった[SOLID原則](https://ja.wikipedia.org/wiki/SOLID)という考え方があります。この中の O は、上記のデザインパターンに見られるOpen-Closeの原則を実践したケースといえます。Openは機能拡張に対して柔軟（オープン）であること、Closeは既存のテスト済みのロジックには影響を与えない（クローズ）ことを求めています。
```

## インターフェースの実体はポインタ

インターフェースのプログラム上の実体はファンクションブロックのプロパティやメソッドへのポインターを格納した配列です。これを、インターフェースポインタと呼びます。

```{note}
InfoSysの参考サイト：[インターフェースポインタについての解説](https://infosys.beckhoff.com/content/1033/tc3_plc_intro/5680748299.html?id=4698838821393963330)
```

メインプログラム上では、全てインターフェースポインタを通してメソッドやプロパティにアクセスします。したがって、プログラム実行中に、サイズの異なる様々なオブジェクトを付け替えても正しくそのオブジェクトのメソッドやプロパティへアクセスする事ができます。

次節より、具体的な事例とサンプルコードについて解説します。